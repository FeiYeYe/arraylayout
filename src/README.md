These are the source files used to generate data in the paper:

  ARRAY LAYOUTS FOR COMPARISON-BASED SEARCHING
  by Paul-Virak Khuong and Pat Morin

The implementations here are not exactly ready for industrial use, but 
they are here for you to play with.  

If you just want a simple example, look in the file example.cpp and 

    make example

If you want to do some timing tests, look in file main.cpp and 

    make main

If you want to see how long it takes to do 2000000 searches on an array
containing 100000000 32-bit integers, you can do

    ./main uint32 uint64 100000000 2000000 | awk '{printf("%-20s %f\n", $1, $7)}'

This will give you a lot of data, you probably want to open main.cpp, go
into the run_tests(n,m) function and comment out the layouts you're not 
interested in.

==Reproducing Our Results==

If you want to try and reproduce the results (i.e., figures) from the paper,
execute

    ./run_script

Note that each invocation of this script kills all the data generated by
any previous invocations, so try to have all the prerequisites installed
first.  In particular, you need a Python installation with matplotlib
and a LaTeX installation.

Using the preceding script will generate PDF figures in the scripts/figs-2
directory.  These have the following relationships to figures in the
paper:

sorted-i -> Fig. 4
sorted-ii -> Fig. 5
sorted-iii -> Fig. 6
sorted-iv -> Fig. 7
sorted-v -> Fig. 8
Fig. 9 (specific hardware)
eytzinger-i -> Fig. 10
eytzinger-ii -> Fig. 11
eytzinger-iii -> Fig. 12
mixed-i -> Fig. 13
mixed-ii -> Fig. 14
btree-i -> Fig. 16
btree-ii -> Fig. 17
veb-i -> Fig. 18
fetchers-4-i -> Fig. 19 (top)
fetchers-8-i -> Fig. 19 (middle)
fetchers-16-i -> Fig. 19 (bottom)
bktrees-i -> Fig. 20
threads2 -> Fig. 21 (top)
threads4 -> Fig. 21 (middle)
threads8 -> Fig. 21 (bottom)
64bit -> Fig. 22
128bit -> Fig. 22
Fig. 23 (specific hardware)
masking-iii -> Fig. 24 (top)
masking-iv -> Fig. 24 (bottom)


