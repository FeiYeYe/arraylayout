![doi](https://zenodo.org/badge/doi/10.5281/zenodo.31047.svg)

# arraylayout
Experiments with memory layouts for binary search.

These are the sources (LaTeX, C++, and Python) for the paper

  ARRAY LAYOUTS FOR COMPARISON-BASED SEARCHING

  by Paul-Virak Khuong and Pat Morin

## About
This project is about trying different memory layouts for searching in
an array, with a focus on improving performance for the most common-case:
When the input fits entirely in RAM. The layouts we try are:

1. sorted: The usual sorted array on which we apply binary search
2. eytzinger: The Eytzinger (or BFS) layout most commonly used implicit
   binary heaps
3. btree: A (B+1)-ary variant of the Eytzinger layout
4. veb: The van Emde Boas layout from the cache-oblivious literature

## Quick start
To run an experiment on your own (linux) machine (with g++ installed):

    cd src
    make main
    ./main uint32 uint32 100000000 10000000

This will test the cost of performing ten million searches in an array
of one hundred million integers.  You'd better have at least 800MB of
free RAM, which you can check with

    free -h

## Results

A webpage with some collected results is being maintained here:

http://cglab.ca/~morin/misc/arraylayout-v2/

## Reproducible Computational Results

This work is in the proccess of earning Reproducible Computational Result
certificate from the Journal of Experimental Algorithmics.  To achieve
this, we have developed scripts that allow anyone with a suitable system
to reproduce the computational results (in this case, figures) in the
paper.

If you want to try and reproduce our results, execute

    ./rcr

*Warning:* These experiments take a while, and each invocation of this
script clobbers all the data generated by any previous invocations,
so try to have all the prerequisites installed first.  In particular,
you need a Python installation with matplotlib and a LaTeX installation.

Using the preceding script will generate PDF figures in the scripts/figs-2
directory.  These have the following relationships to figures in the
paper:

    sorted-i -> Fig. 4
    sorted-ii -> Fig. 5
    sorted-iii -> Fig. 6
    sorted-iv -> Fig. 7
    sorted-v -> Fig. 8
    Fig. 9 (specific hardware)
    eytzinger-i -> Fig. 10
    eytzinger-ii -> Fig. 11
    eytzinger-iii -> Fig. 12
    mixed-i -> Fig. 13
    mixed-ii -> Fig. 14
    btree-i -> Fig. 16
    btree-ii -> Fig. 17
    veb-i -> Fig. 18
    fetchers-4-i -> Fig. 19 (top)
    fetchers-8-i -> Fig. 19 (middle)
    fetchers-16-i -> Fig. 19 (bottom)
    bktrees-i -> Fig. 20
    threads2 -> Fig. 21 (top)
    threads4 -> Fig. 21 (middle)
    threads8 -> Fig. 21 (bottom)
    64bit -> Fig. 22
    128bit -> Fig. 22
    Fig. 23 (specific hardware)
    masking-iii -> Fig. 24 (top)
    masking-iv -> Fig. 24 (bottom)
    

